function [J_x,J_be] = setup_jacobian(param,ss,config,T)
% This function generates the jacobian matrices
jac.base = sparse(param.nX*T,param.nX*T);
%%  BLOCKS
%   order of variables X_t = [Y_t Pi_t b_t T_t M_t R_t]
%   order of equations:
%   PC,             0 = beta Pi(t+1) + kappa Y(t) - Pi(t) 
%   Gov BC,         0 = b/Pi^2*Pi(t)-b(t-1)/Pi+b(t)/R-b/R^2*R(t)+tau(t) -
%   (-egy *Y(t))
%   Fiscal Rule     0 = Bt - (1-rhob)*B(t-1) + eby*Y(t)
%   Asset M Clear   0 = At - Bt
%   Monetary aggregate
%   Taylor Rule,

%   NKPC 
jac.base(1:T,:)     = [ [param.kap*eye(T)] ...
                        [-eye(T)+param.bet*diag(ones(T-1,1),1)] ...
                        [zeros(T)] ...
                        [zeros(T)] ...
                        [zeros(T)] ...
                        [zeros(T)]];
%   Gov BC
jac.base(T+1:2*T,:) = [ [0*eye(T)] ...
                        [ss.b/ss.Pi^2*eye(T)] ...
                        [eye(T)./ss.R-diag(ones(T-1,1),-1)./ss.Pi] ...
                        [eye(T)] ...
                        [zeros(T)] ...
                        [-eye(T)*ss.b/ss.R^2]]; 
%   Taxes                    
jac.base(2*T+1:3*T,:) = [ [zeros(T)] ...
                        [zeros(T)] ...
                        [eye(T)] ...
                        [zeros(T)] ...
                        [zeros(T)] ...
                        [zeros(T)]]; 
%   Monetary Aggregate                   
jac.base(4*T+1:5*T,:) = [[eye(T)*0] ...
                        [eye(T)] ...
                        [zeros(T)] ...
                        [zeros(T)] ...
                        [-eye(T)+diag(ones(T-1,1),-1)] ...
                        [zeros(T)]]; 
%   Taylor rule                    
jac.base(5*T+1:6*T,:) = [ [-param.phy*eye(T)] ...
                        [-param.php*eye(T)] ...
                        [zeros(T)] ...
                        [zeros(T)] ...
                        [zeros(T)] ...
                        [eye(T)]];  
%   Block 4: Asset market (HA part!!!) 
epsv = NaN(param.N_a*param.N_z,T);
epsv(:,1) = ss.ga(:)'*ss.L';
for it = 2:T
    epsv(:,it) =  epsv(:,it-1)'*ss.L';
end 
epsv = epsv';


shock   = 0.000001;  tic


AA1      = HA_jac(shock,0,0,0,0,ss,param,T,epsv)/shock;toc;tic
BB1      = HA_jac(0,shock,0,0,0,ss,param,T,epsv)/shock;toc;tic
CC1      = HA_jac(0,0,shock,0,0,ss,param,T,epsv)/shock;toc;tic
DD1      = HA_jac(0,0,0,shock,0,ss,param,T,epsv)/shock;toc;tic
EE1      = HA_jac(0,0,0,0,shock,ss,param,T,epsv)/shock;toc  % Beta shock 
jac.base(3*T+1:4*T,:) = [AA1 BB1 -eye(T) DD1 zeros(T) CC1];     % check if condition is b = integ(a_i)

% Compute Jacobian
J_x     = jac.base;
% Compute Jacobian only in response to changes in beta (equivalent to the
% nominal rate for HH)
J_be    = sparse([zeros(3*T,T);EE1;zeros(T);zeros(T)]);